unit SrvDB_Impl;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ This is where you are supposed to code the implementation of your objects. }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, SysUtils, 
  {RemObjects:} uROXMLIntf, uROClientIntf, uROTypes, uROServer, uROServerIntf, uROSessions,
  {Required:} uRORemoteDataModule,
  {Generated:} FZSale_Intf, Provider;

type
  { TSrvDB }
  TSrvDB = class(TRORemotable, ISrvDB)
  private
    procedure SQ(nZID,nDID: AnsiString; const nSQL: AnsiString;
     out nData: Binary; var nResult: SrvResult);
    procedure SE(nZID,nDID: AnsiString; const nSQL: SQLItem; var nResult: SrvResult);
    procedure SU(nZID,nDID: AnsiString; const nSQLList: SQLItems;
     const nAtomic: Boolean; var nResult: SrvResult);
  protected
    { ISrvDB methods }
    function SQLQuery(const nZID: AnsiString; const nDID: AnsiString;
     const nSQL: AnsiString; out nData: Binary): SrvResult;
    function SQLExecute(const nZID: AnsiString; const nDID: AnsiString;
     const nSQL: SQLItem): SrvResult;
    function SQLUpdates(const nZID: AnsiString; const nDID: AnsiString;
     const nSQLList: SQLItems; const nAtomic: Boolean): SrvResult;
  end;

implementation

uses
  ULibFun, UDataModule, UROModule, UMgrChannel, USysService, USysConst, USysdb,
  uROBinaryHelpers;

function TSrvDB.SQLQuery(const nZID: AnsiString; const nDID: AnsiString;
 const nSQL: AnsiString; out nData: Binary): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    SQ(nZID, nDID, nSQL, nData, Result);
    //do action
    
    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ SQLQuery ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ SQLQuery ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

function TSrvDB.SQLExecute(const nZID: AnsiString; const nDID: AnsiString;
 const nSQL: SQLItem): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    SE(nZID, nDID, nSQL, Result);
    //do action

    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ SQLExecute ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ SQLExecute ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

function TSrvDB.SQLUpdates(const nZID: AnsiString; const nDID: AnsiString;
 const nSQLList: SQLItems; const nAtomic: Boolean): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    SU(nZID, nDID, nSQLList, nAtomic, Result);
    //do action
    
    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ SQLUpdates ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ SQLUpdates ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

//------------------------------------------------------------------------------
//Date: 2011-11-4
//Parm: 终端;代理;语句;结果
//Desc: 执行SQL查询
procedure TSrvDB.SQ(nZID, nDID: AnsiString; const nSQL: AnsiString;
  out nData: Binary; var nResult: SrvResult);
var nRes,nTmp: SrvResult;
    nChannel: PChannelItem;
begin
  with ROModule.LockModuleStatus^,gROModuleParam do
  try
    FNumDB := FNumDB + 1;
    FNumSQLQuery := FNumSQLQuery + 1;

    nZID := FTerminalID;
    nDID := FSpID;
  finally
    ROModule.ReleaseStatusLock;
  end;

  nRes := nil;
  nChannel := gChannelManager.LockChannel(cChannel_DB);
  try
    if not Assigned(nChannel) then
    begin
      nResult.DataStr := '无可用数据通道';
      nResult.Action := cAction_Error; Exit;
    end;

    with nChannel^ do
    begin
      if not Assigned(FChannel) then
        FChannel := CoSrvDB.Create(FMsg, FHttp);
      //xxxxx

      FHttp.TargetURL := gROModuleParam.FRemoteURL;
      nRes := ISrvDB(FChannel).SQLQuery(nZID, nDID, nSQL, nData);

      if Assigned(nRes) then
      begin
        nTmp := nResult;
        nResult := nRes;
        nRes := nTmp;
      end;
    end;
  finally
    nRes.Free;
    gChannelManager.ReleaseChannel(nChannel);
  end;
end;

//Date: 2011-11-4
//Parm: 终端店;代理商;语句
//Desc: 执行SQL操作
procedure TSrvDB.SE(nZID, nDID: AnsiString; const nSQL: SQLItem; var nResult: SrvResult);
var nRes,nTmp: SrvResult;
    nChannel: PChannelItem;
begin
  with ROModule.LockModuleStatus^,gROModuleParam do
  try
    FNumDB := FNumDB + 1;
    FNumSQLExecute := FNumSQLExecute + 1;

    nZID := FTerminalID;
    nDID := FSpID;
  finally
    ROModule.ReleaseStatusLock;
  end;

  nRes := nil;
  nChannel := gChannelManager.LockChannel(cChannel_DB);
  try
    if not Assigned(nChannel) then
    begin
      nResult.DataStr := '无可用数据通道';
      nResult.Action := cAction_Error; Exit;
    end;

    with nChannel^ do
    begin
      if not Assigned(FChannel) then
        FChannel := CoSrvDB.Create(FMsg, FHttp);
      //xxxxx

      FHttp.TargetURL := gROModuleParam.FRemoteURL;
      nRes := ISrvDB(FChannel).SQLExecute(nZID, nDID, nSQL);

      if Assigned(nRes) then
      begin
        nTmp := nResult;
        nResult := nRes;
        nRes := nTmp;
      end;
    end;
  finally
    nRes.Free;
    gChannelManager.ReleaseChannel(nChannel);
  end;
end;

//Date: 2011-11-4
//Parm: 终端;代理;语句;原子操作
//Desc: 执行批量操作
procedure TSrvDB.SU(nZID, nDID: AnsiString; const nSQLList: SQLItems;
  const nAtomic: Boolean; var nResult: SrvResult);
var nIdx: Integer;
    nList: SQLItems;
    nRes,nTmp: SrvResult;
    nChannel: PChannelItem;
begin
  with ROModule.LockModuleStatus^,gROModuleParam do
  try
    FNumDB := FNumDB + 1;
    FNumSQLUpdates := FNumSQLUpdates + 1;

    nZID := FTerminalID;
    nDID := FSpID;
  finally
    ROModule.ReleaseStatusLock;
  end;

  nRes := nil;
  nList := nil;
  nChannel := gChannelManager.LockChannel(cChannel_DB);
  try
    if not Assigned(nChannel) then
    begin
      nResult.DataStr := '无可用数据通道';
      nResult.Action := cAction_Error; Exit;
    end;

    nList := SQLItems.Create;
    for nIdx:=0 to nSQLList.Count - 1 do
    with nList.Add do
    begin
      SQL := nSQLList[nIdx].SQL;
      IfRun := nSQLList[nIdx].IfRun;
      IfType := nSQLList[nIdx].IfType;
    end;
    //代理需要对象翻译

    with nChannel^ do
    begin
      if not Assigned(FChannel) then
        FChannel := CoSrvDB.Create(FMsg, FHttp);
      //xxxxx

      FHttp.TargetURL := gROModuleParam.FRemoteURL;
      nRes := ISrvDB(FChannel).SQLUpdates(nZID, nDID, nList, nAtomic);
      nList := nil;
      
      if Assigned(nRes) then
      begin
        nTmp := nResult;
        nResult := nRes;
        nRes := nTmp;
      end;
    end;
  finally
    nRes.Free;
    gChannelManager.ReleaseChannel(nChannel);

    try
      nList.Free;
    except
      //ignor any error
    end;
  end;
end;

end.
