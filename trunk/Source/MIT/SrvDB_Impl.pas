unit SrvDB_Impl;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ This is where you are supposed to code the implementation of your objects. }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, SysUtils, 
  {RemObjects:} uROXMLIntf, uROClientIntf, uROTypes, uROServer, uROServerIntf, uROSessions,
  {Required:} uRORemoteDataModule,
  {Generated:} FZSale_Intf, Provider;

type
  { TSrvDB }
  TSrvDB = class(TRORemotable, ISrvDB)
  private
    FDataSet: TDataSetProvider;
    //数据对象
    procedure SQ(const nZID: AnsiString; const nDID: AnsiString;
     const nSQL: AnsiString; out nData: Binary; var nResult: SrvResult);
    procedure SE(const nZID: AnsiString; const nDID: AnsiString;
     const nSQL: SQLItem; var nResult: SrvResult);
    procedure SU(const nZID: AnsiString; const nDID: AnsiString;
     const nSQLList: SQLItems; const nAtomic: Boolean; var nResult: SrvResult);
  protected
    { ISrvDB methods }
    function SQLQuery(const nZID: AnsiString; const nDID: AnsiString;
     const nSQL: AnsiString; out nData: Binary): SrvResult;
    function SQLExecute(const nZID: AnsiString; const nDID: AnsiString;
     const nSQL: SQLItem): SrvResult;
    function SQLUpdates(const nZID: AnsiString; const nDID: AnsiString;
     const nSQLList: SQLItems; const nAtomic: Boolean): SrvResult;
  public
    constructor Create; override;
    destructor Destroy; override;
  end;

implementation

uses
  ULibFun, UDataModule, UROModule, UMgrDBConn, USysService, USysConst, USysdb,
  uROBinaryHelpers;

constructor TSrvDB.Create;
begin
  inherited;
  FDataSet := TDataSetProvider.Create(nil);
end;

destructor TSrvDB.Destroy;
begin
  FDataSet.Free;
  inherited;
end;

function TSrvDB.SQLQuery(const nZID: AnsiString; const nDID: AnsiString;
 const nSQL: AnsiString; out nData: Binary): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    SQ(nZID, nDID, nSQL, nData, Result);
    //do action

    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ SQLQuery ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ SQLQuery ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

function TSrvDB.SQLExecute(const nZID: AnsiString; const nDID: AnsiString;
 const nSQL: SQLItem): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    SE(nZID, nDID, nSQL, Result);
    //do action

    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ SQLExecute ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ SQLExecute ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

function TSrvDB.SQLUpdates(const nZID: AnsiString; const nDID: AnsiString;
 const nSQLList: SQLItems; const nAtomic: Boolean): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    SU(nZID, nDID, nSQLList, nAtomic, Result);
    //do action
    
    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ SQLUpdates ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ SQLUpdates ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

//------------------------------------------------------------------------------
//Date: 2011-11-4
//Parm: 终端;代理;语句;结果
//Desc: 执行SQL查询
procedure TSrvDB.SQ(const nZID, nDID, nSQL: AnsiString;
  out nData: Binary; var nResult: SrvResult);
var nStr: string;
    nInt: Integer;
    nWorker: PDBWorker;
begin
  with ROModule.LockModuleStatus^,gROModuleParam do
  try
    FNumDB := FNumDB + 1;
    FNumSQLQuery := FNumSQLQuery + 1;
    nInt := FMaxRecordCount;
  finally
    ROModule.ReleaseStatusLock;
  end;

  nWorker := RoModule.LockDBWorker(nDID, nStr);
  try
    if not Assigned(nWorker) then
    begin
      nResult.DataStr := nStr;
      nResult.Action := cAction_Error; Exit;
    end;

    if not nWorker.FConn.Connected then
      nWorker.FConn.Connected := True;
    //连接数据库

    with gDBConnManager.WorkerQuery(nWorker, nSQL) do
    begin
      if (not Active) or (RecordCount < 0) then
      begin
        nResult.DataStr := '数据库查询失败';
        nResult.Action := cAction_Error; Exit;
      end;

      if (nInt > 0) and (RecordCount > nInt) then
      begin
        nStr := '当前记录:%d条,服务限制:%d条,请缩小查询范围!';
        nResult.DataStr := Format(nStr, [RecordCount, nInt]);
        nResult.Action := cAction_Error;

        nWorker.FQuery.Close;
        Exit;
      end;

      FDataSet.DataSet := nWorker.FQuery;
      nData := BinaryFromVariant(FDataSet.GetRecords(-1, nInt,
               MetaDataOption + ResetOption));
      nWorker.FQuery.Close;

      nResult.Re_sult := True;
      nResult.DataStr := '数据库查询成功';
    end;
  finally
    ROModule.ReleaseDBWorker(nDID, nWorker);
  end;
end;

//Date: 2011-11-4
//Parm: 终端店;代理商;语句
//Desc: 执行SQL操作
procedure TSrvDB.SE(const nZID, nDID: AnsiString;
  const nSQL: SQLItem; var nResult: SrvResult);
var nStr: string;
    nInt: Integer;
    nWorker: PDBWorker;
begin
  with ROModule.LockModuleStatus^,gROModuleParam do
  try
    FNumDB := FNumDB + 1;
    FNumSQLExecute := FNumSQLExecute + 1;
  finally
    ROModule.ReleaseStatusLock;
  end;

  nWorker := RoModule.LockDBWorker(nDID, nStr);
  try
    if not Assigned(nWorker) then
    begin
      nResult.DataStr := nStr;
      nResult.Action := cAction_Error; Exit;
    end;

    if not nWorker.FConn.Connected then
      nWorker.FConn.Connected := True;
    //连接数据库

    if nSQL.IfRun <> '' then
    begin
      case nSQL.IfType of
       1,2: nInt := gDBConnManager.WorkerQuery(nWorker, nSQL.IfRun).RecordCount;
       5,6: nInt := gDBConnManager.WorkerExec(nWorker, nSQL.IfRun) else nInt := 0;
      end;

      case nSQL.IfType of
       1: nResult.Re_sult := nInt < 1;
       2: nResult.Re_sult := nInt > 0; //查询记录
       5: nResult.Re_sult := nInt < 1;
       6: nResult.Re_sult := nInt > 0; //影响记录
      end;

      if not nResult.Re_sult then
      begin
        nResult.DataStr := '条件未满足,操作终止!';
        nResult.Action := cAction_Warn; Exit;
      end;
    end;

    nResult.DataInt := gDBConnManager.WorkerExec(nWorker, nSQL.SQL);
    nResult.Re_sult := True;
  finally
    ROModule.ReleaseDBWorker(nDID, nWorker);
  end;
end;

//Date: 2011-11-4
//Parm: 终端;代理;语句;原子操作
//Desc: 执行批量操作
procedure TSrvDB.SU(const nZID, nDID: AnsiString; const nSQLList: SQLItems;
  const nAtomic: Boolean; var nResult: SrvResult);
var nStr: string;
    nBool: Boolean;
    nWorker: PDBWorker;
    nIdx,nInt: Integer;
begin
  with ROModule.LockModuleStatus^,gROModuleParam do
  try
    FNumDB := FNumDB + 1;
    FNumSQLUpdates := FNumSQLUpdates + 1;
  finally
    ROModule.ReleaseStatusLock;
  end;

  if nSQLList.Count < 1 then
  begin
    nResult.DataStr := '没有可执行语句.';
    nResult.Action := cAction_Error; Exit;
  end;

  nWorker := RoModule.LockDBWorker(nDID, nStr);
  try
    if not Assigned(nWorker) then
    begin
      nResult.DataStr := nStr;
      nResult.Action := cAction_Error; Exit;
    end;

    if not nWorker.FConn.Connected then
      nWorker.FConn.Connected := True;
    //连接数据库

    if nAtomic then nWorker.FConn.BeginTrans;
    try
      for nIdx:=0 to nSQLList.Count - 1 do
      with gDBConnManager do
      begin
        if nSQLList[nIdx].IfRun <> '' then
        begin
          case nSQLList[nIdx].IfType of
           1,2: nInt := WorkerQuery(nWorker, nSQLList[nIdx].IfRun).RecordCount;
           5,6: nInt := WorkerExec(nWorker, nSQLList[nIdx].IfRun) else nInt := 0;
          end;

          case nSQLList[nIdx].IfType of
           1: nBool := nInt < 1;
           2: nBool := nInt > 0; //查询记录
           5: nBool := nInt < 1;
           6: nBool := nInt > 0; //影响记录
           else nBool := False;
          end;

          if not nBool then Continue;
          //不满足条件
        end;

        nInt := WorkerExec(nWorker, nSQLList[nIdx].SQL);
        nResult.DataInt := nResult.DataInt + nInt;
      end;

      if nAtomic then
        nWorker.FConn.CommitTrans;
      nResult.Re_sult := True;
    except
      on nErr: Exception do
      begin
        if nAtomic then
          nWorker.FConn.RollbackTrans;
        //xxxxx

        nResult.DataStr := nErr.Message;
        nResult.Action := cAction_Error;
        nResult.Re_sult := False;
      end;
    end;
  finally
    ROModule.ReleaseDBWorker(nDID, nWorker);
  end;
end;

end.
