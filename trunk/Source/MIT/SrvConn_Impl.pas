unit SrvConn_Impl;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ This is where you are supposed to code the implementation of your objects. }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, SysUtils, 
  {RemObjects:} uROXMLIntf, uROClientIntf, uROTypes, uROServer, uROServerIntf, uROSessions,
  {Required:} uRORemoteDataModule,
  {Generated:} FZSale_Intf;

type
  { TSrvConn }
  TSrvConn = class(TRORemotable, ISrvConn)
  private
    procedure SI(const nZID, nDID, nMAC, nUser, nPwd, nVerMIT,
     nVerClient : AnsiString; var nResult: SrvResult);
    procedure RM(const nZID, nDID, nMAC: AnsiString;
     const nIsFirst: Boolean; var nResult: SrvResult);
  protected
    { ISrvConn methods }
    function SweetHeart: SrvResult;
    function SignIn(const nZID: AnsiString; const nDID: AnsiString; const nMAC: AnsiString; const nUser: AnsiString; const nPwd: AnsiString; const nVerMIT: AnsiString; const nVerClient: AnsiString): SrvResult;
    function RegistMe(const nZID: AnsiString; const nDID: AnsiString; const nMAC: AnsiString; const nIsFirst: Boolean): SrvResult;
  end;

implementation

uses
  ULibFun, UDataModule, UROModule, UMgrDBConn, USysService, USysConst, USysdb,
  ZnMD5;

//Desc: 心跳指令
function TSrvConn.SweetHeart: SrvResult;
begin
  with ROModule.LockModuleStatus^ do
  try
    FNumConn := FNumConn + 1;
    FNumSweetHeart := FNumSweetHeart + 1;
  finally
    ROModule.ReleaseStatusLock;
  end;

  Result := MakeSrvResult;
  Result.Re_sult := True;
  Result.DataStr := DateTime2Str(Now);
end;

function TSrvConn.SignIn(const nZID: AnsiString; const nDID: AnsiString;
 const nMAC: AnsiString; const nUser: AnsiString; const nPwd: AnsiString;
 const nVerMIT: AnsiString; const nVerClient: AnsiString): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    SI(nZID, nDId, nMAC, nUser, nPwd, nVerMIT, nVerClient, Result);
    //do action
    
    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ SignIn ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ SignIn ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

function TSrvConn.RegistMe(const nZID: AnsiString; const nDID: AnsiString; const nMAC: AnsiString; const nIsFirst: Boolean): SrvResult;
var nStr: string;
begin
  Result := MakeSrvResult;
  try
    RM(nZID, nDID, nMAC, nIsFirst, Result);
    //do action
    
    if Result.Re_sult then
         nStr := cAction_Succ
    else nStr := cAction_Fail;

    nStr := Format('Fun:[ RegistMe ] RES:[ %s ] ACT_ID:[ %s ]', [nStr, nZID]);
    ShowDebugLog(nStr, False);
  except
    on e:Exception do
    begin
      Result.Re_sult := False;
      Result.DataStr := e.Message;
      Result.Action := cAction_Error;

      with ROModule.LockModuleStatus^,gROModuleParam do
      try
        FNumActionError := FNumActionError + 1;
      finally
        ROModule.ReleaseStatusLock;
      end;

      nStr := 'Fun:[ RegistMe ] ACT_ID:[ %s ] ERR:[ %s ]';
      nStr := Format(nStr, [nZID, e.Message]);
      ShowDebugLog(nStr, True);
    end;
  end;
end;

//------------------------------------------------------------------------------
//Date: 2011-10-31
//Parm: 终端;代理;MAC;用户名;密码;版本
//Desc: 执行登录动作
procedure TSrvConn.SI(const nZID, nDID, nMAC, nUser, nPwd, nVerMIT,
 nVerClient : AnsiString; var nResult: SrvResult);
var nStr: string;
    nWorker: PDBWorker;
begin
  with ROModule.LockModuleStatus^,gROModuleParam do
  try
    FNumConn := FNumConn + 1;
    FNumSignIn := FNumSignIn + 1;

    if nVerMIT <> FVerLocalMIT then
      nResult.DataStr := FURLLocalMIT;
    if nVerClient <> FVerClient then
      nResult.DataStr := FURLClient;
    //xxxxx

    if (nVerMIT <> FVerLocalMIT) or (nVerClient <> FVerClient) then
    begin
      nResult.Re_sult := False;
      nResult.Action := cAction_Jump; Exit;
    end;
  finally
    ROModule.ReleaseStatusLock;
  end;

  nWorker := RoModule.LockDBWorker(nDID, nStr);
  try
    if not Assigned(nWorker) then
    begin
      nResult.DataStr := nStr;
      nResult.Action := cAction_Error; Exit;
    end;

    if not nWorker.FConn.Connected then
      nWorker.FConn.Connected := True;
    //连接数据库

    nStr := 'Select * From %s Where TerminalId=%s';
    nStr := Format(nStr, [sTable_Terminal, nZID]);

    with gDBConnManager.WorkerQuery(nWorker, nStr) do
    if RecordCount > 0 then
    begin
      if CompareText(FieldByName('Mac').AsString, nMAC) <> 0 then
      begin
        nResult.DataStr := '身份验证失败,登录被禁止!';
        nResult.Action := cAction_Error; Exit;
      end;

      if FieldByName('IsDeleted').AsInteger = 1 then
      begin
        nResult.DataStr := '该终端店已被管理员删除!';
        nResult.Action := cAction_Error; Exit;
      end;

      if CompareText(FieldByName('TerAccount').AsString, nUser) = 0 then
      begin
        nStr := MD5Print(MD5String(nPwd));
        //md5 password
        
        if CompareText(nStr, FieldByName('TerPwd').AsString) = 0 then
        begin
          nResult.Re_sult := True;
          nResult.DataStr := '登录验证成功!';
          nResult.DataInt := cLevel_Master;
        end else
        begin
          nResult.DataStr := '用户密码错误!';
          nResult.Action := cAction_Error;
        end;

        Exit;
      end;
    end else
    begin
      nResult.DataStr := '终端店编号无效.';
      nResult.Action := cAction_Error; Exit;
    end;

    //--------------------------------------------------------------------------
    nStr := 'Select * From %s Where U_TerminalId=''%s'' and U_Name=''%s''';
    nStr := Format(nStr, [sTable_TerminalUser, nZID, nUser]);

    with gDBConnManager.WorkerQuery(nWorker, nStr) do
    if RecordCount > 0 then
    begin
      if CompareText(FieldByName('U_Pwd').AsString, nPwd) = 0 then
        begin
          nResult.Re_sult := True;
          nResult.DataStr := '登录验证成功!';
          nResult.DataInt := cLevel_Employer;
        end else
        begin
          nResult.DataStr := '用户密码错误!';
          nResult.Action := cAction_Error;
        end;
    end else
    begin
      nResult.DataStr := '用户名不存在.';
      nResult.Action := cAction_Error;
    end;
  finally
    ROModule.ReleaseDBWorker(nDID, nWorker);
  end;
end;

//Desc: 执行注册动作
procedure TSrvConn.RM(const nZID, nDID, nMAC: AnsiString;
  const nIsFirst: Boolean; var nResult: SrvResult);
var nStr: string;
    nWorker: PDBWorker;
begin
  with ROModule.LockModuleStatus^ do
  try
    FNumConn := FNumConn + 1;
    FNumRegister := FNumRegister + 1;
  finally
    ROModule.ReleaseStatusLock;
  end;

  nWorker := RoModule.LockDBWorker(nDID, nStr);
  try
    if not Assigned(nWorker) then
    begin
      nResult.DataStr := nStr;
      nResult.Action := cAction_Error; Exit;
    end;

    if not nWorker.FConn.Connected then
      nWorker.FConn.Connected := True;
    //连接数据库

    nStr := 'Select * From %s Where TerminalId=%s';
    nStr := Format(nStr, [sTable_Terminal, nZID]);

    with gDBConnManager.WorkerQuery(nWorker, nStr) do
    if RecordCount > 0 then
    begin
      if CompareText(FieldByName('Mac').AsString, nMAC) = 0 then
      begin
        nResult.Re_sult := True;
        nResult.DataStr := '终端店已通过验证!';
        nResult.Action := cAction_Hint; Exit;
      end;

      if FieldByName('Mac').AsString = '' then
      begin
        nStr := 'Update %s Set Mac=''%s'' Where TerminalId=%s';
        nStr := Format(nStr, [sTable_Terminal, nMAC, nZID]);
        gDBConnManager.WorkerExec(nWorker, nStr);

        nResult.Re_sult := True;
        nResult.DataStr := '新终端店验证成功!';
        nResult.Action := cAction_Hint; Exit;
      end;

      nStr := 'Update %s Set M_MAC=''%s'' ' +
              'Where M_TerminalId=''%s'' And M_Allow<>''%s''';
      nStr := Format(nStr, [sTable_MACRebind, nMAC, nZID, sFlag_Yes]);

      if gDBConnManager.WorkerExec(nWorker, nStr) > 0 then
      begin
        nResult.Re_sult := True;
        nResult.DataStr := '验证申请更新成功,请等待管理员审核!';
        nResult.Action := cAction_Hint; Exit;
      end;

      nStr := 'Insert Into %s(M_MAC,M_TerminalId,M_ReqTime) Values(''%s'',' +
              '''%s'', %s)';
      nStr := Format(nStr, [sTable_MACRebind, nMAC, nZID, FDM.SQLServerNow]);

      if gDBConnManager.WorkerExec(nWorker, nStr) > 0 then
      begin
        nResult.Re_sult := True;
        nResult.DataStr := '验证申请提交成功,请等待管理员审核!';
        nResult.Action := cAction_Hint; Exit;
      end;
    end else
    begin
      nResult.DataStr := '终端店编号无效.';
      nResult.Action := cAction_Error; Exit;
    end;
  finally
    ROModule.ReleaseDBWorker(nDID, nWorker);
  end;
end;

end.
